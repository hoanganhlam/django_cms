{"head":{"title":"Rails models","category":"Rails","layout":"2017/sheet"},"body":[{"title":"Generating","elms":"\n    $ rails g model User\n\nUsing models\n------------\n","h2":null},{"title":"Query methods","elms":"\n```ruby\nitems = Model\n  .where(first_name: 'Harvey')\n  .where('id = 3')\n  .where('id = ?', 3)\n```\n\n```ruby\n  .order(:title)\n  .order(title: :desc)\n  .order(\"title DESC\")\n```\n\n```ruby\n  .reorder(:title)  # discards other .order's\n  .rewhere(...)     # discards other .where's\n```\n\n```ruby\n  .limit(2)\n  .offset(1)\n  .uniq\n```\n\nSee: [QueryMethods](http://devdocs.io/rails/activerecord/querymethods)\n","h2":null},{"title":"Advanced query methods","elms":"\n```ruby\nitems = Model\n  .select(:id)\n  .select([:id, :name])\n```\n\n```ruby\n  .group(:name)   # GROUP BY name\n  .group('name AS grouped_name, age')\n  .having('SUM(price) > 30')  # needs to be chained with .group\n```\n\n```ruby\n  .includes(:user)\n  .includes(user: [:articles])\n```\n\n```ruby\n  .references(:posts)\n  # aka: .where(\"posts.name = 'foo'\").references(:posts)\n```\n","h2":null},{"title":"Finder methods","elms":"\n```ruby\nitem = Model.find(id)\nitem = Model.find_by_email(email)\nitem = Model.where(email: email).first\n```\n\n```ruby\nModel\n  .exists?(5)\n  .exists?(name: \"David\")\n```\n\n```ruby\n  .first\n  .last\n  .find_nth(4, [offset])\n```\n\nSee: [FinderMethods](http://devdocs.io/rails/activerecord/findermethods)\n","h2":null},{"title":"Persistence","elms":"\n```ruby\nitem.new_record?\nitem.persisted?\nitem.destroyed?\n\nitem.serialize_hash\n```\n\n```ruby\nitem.save\nitem.save!      # Same as above, but raises an Exception\n```\n\n```ruby\nitem.update  name: 'John'  # Saves immediately\nitem.update! name: 'John'\n```\n\n```ruby\nitem.update_column  :name, 'John'  # skips validations and callbacks\nitem.update_columns  name: 'John'\nitem.update_columns! name: 'John'\n```\n\n```ruby\nitem.touch                 # updates :updated_at\nitem.touch :published_at\n```\n\n```ruby\nitem.destroy\nitem.delete  # skips callbacks\n```\n\n```ruby\nModel.create     # Same an #new then #save\nModel.create!    # Same as above, but raises an Exception\n```\n\nSee: [Persistence](http://devdocs.io/rails/activerecord/persistence)\n","h2":null},{"title":"Attribute Assignment","elms":"\n```ruby\nitem.attributes                      # #<Hash>\n```\n\n```ruby\nitem.attributes = { name: 'John' }   # Merges attributes in. Doesn't save.\nitem.assign_attributes name: 'John'  # Same as above\n```\n\nSee: [AttributeAssignment](http://devdocs.io/rails/activerecord/attributeassignment)\n","h2":null},{"title":"Dirty","elms":"\n```ruby\nitem.changed?\nitem.changed             # ['name']\nitem.changed_attributes  # { 'name' => 'Bob' } - original values\nitem.changes             # { 'name' => ['Bob', 'Robert'] }\nitem.previous_changes    # available after #save\nitem.restore_attributes\n```\n\n```ruby\nitem.name = 'Robert'\nitem.name_was         # 'Bob'\nitem.name_change      # [ 'Bob', 'Robert' ]\nitem.name_changed?    # true\nitem.name_changed?(from: 'Bob', to: 'Robert')\n```\n\nSee: [Dirty](http://devdocs.io/rails/activemodel/dirty)\n","h2":null},{"title":"Validations","elms":"\n```ruby\nitem.valid?\nitem.invalid?\n```\n\nSee: [Validations](http://devdocs.io/rails/activerecord/validations)\n","h2":null},{"title":"Calculations","elms":"\n```ruby\nPerson.count\nPerson.count(:age)    # counts non-nil's\n```\n\n```ruby\nPerson.average(:age)\nPerson.maximum(:age)\nPerson.minimum(:age)\nPerson.sum('2 * age')\n```\n\n```ruby\nPerson.calculate(:count, :all)\n```\n\nAdvanced:\n\n```ruby\nPerson.distinct.count\nPerson.group(:city).count\n```\n\nSee: [Calculations](http://devdocs.io/rails/activerecord/calculations)\n","h2":null},{"title":"Dynamic attribute-based finders","elms":"\nGiven a field called `name`:\n{: .-setup}\n\n```ruby\n# Returns one record\nPerson.find_by_name(name)\nPerson.find_last_by_name(name)\nPerson.find_or_create_by_name(name)\nPerson.find_or_initialize_by_name(name)\n```\n\n```ruby\n# Returns a list of records\nPerson.find_all_by_name(name)\n```\n\n```ruby\n# Add a bang to make it raise an exception\nPerson.find_by_name!(name)\n```\n\n```ruby\n# You may use `scoped` instead of `find`\nPerson.scoped_by_user_name\n```\n\nAssociations\n------------\n","h2":null},{"title":"Associations","elms":"\n- `belongs_to`\n- `has_one`\n- `has_many`\n- `has_many :through`\n- `has_one :through`\n- `has_and_belongs_to_many`\n","h2":null},{"title":"Has many","elms":"\n```ruby\nbelongs_to :parent, :foreign_key => 'parent_id' class_name: 'Folder'\nhas_many :folders, :foreign_key => 'parent_id', class_name: 'Folder'\n\nhas_many :comments,                -> { order('posted_on DESC') }\nhas_many :comments,    :include    => :author\nhas_many :people,      :class_name => \"Person\"\nhas_many :people,      :conditions => \"deleted = 0\"\nhas_many :tracks,                  -> { order(:position) }\nhas_many :comments,    :dependent  => :nullify\nhas_many :comments,    :dependent  => :destroy\nhas_many :tags,        :as         => :taggable\nhas_many :reports,     :readonly   => true\nhas_many :subscribers, :through    => :subscriptions, class_name: \"User\", :source => :user\nhas_many :subscribers, :finder_sql =>\n    'SELECT DISTINCT people.* ' +\n    'FROM people p, post_subscriptions ps ' +\n    'WHERE ps.post_id = #{id} AND ps.person_id = p.id ' +\n    'ORDER BY p.first_name'\n```\n","h2":null},{"title":"belongs to","elms":"\n```ruby\nbelongs_to :author,\n  :dependent      => :destroy    # or :delete\n\n  :class_name     => \"Person\"\n  :select         => \"*\"\n  :counter_cache  => true\n  :counter_cache  => :custom_counter\n  :include        => \"Book\"\n  :readonly       => true\n\n  :conditions     => 'published = true'\n\n  :touch          => true\n  :touch          => :authors_last_updated_at\n\n  :primary_key    => \"name\"\n  :foreign_key    => \"author_name\"\n```\n","h2":null},{"title":"Many-to-many","elms":"\nIf you have a join model:\n{: .-setup}\n\n```ruby\nclass Programmer < ActiveRecord::Base\n  has_many :assignments\n  has_many :projects, :through => :assignments\nend\n```\n{: data-line=\"2,3\"}\n\n```ruby\nclass Project < ActiveRecord::Base\n  has_many :assignments\n  has_many :programmers, :through => :assignments\nend\n```\n{: data-line=\"2,3\"}\n\n```ruby\nclass Assignment\n  belongs_to :project\n  belongs_to :programmer\nend\n```\n{: data-line=\"2,3\"}\n","h2":null},{"title":"Many-to-many (HABTM)","elms":"\n```ruby\nhas_and_belongs_to_many :projects\nhas_and_belongs_to_many :projects, :include => [ :milestones, :manager ]\nhas_and_belongs_to_many :nations, :class_name => \"Country\"\nhas_and_belongs_to_many :categories, :join_table => \"prods_cats\"\nhas_and_belongs_to_many :categories, :readonly => true\nhas_and_belongs_to_many :active_projects, :join_table => 'developers_projects', :delete_sql =>\n\"DELETE FROM developers_projects WHERE active=1 AND developer_id = #{id} AND project_id = #{record.id}\"\n```\n","h2":null},{"title":"Polymorphic associations","elms":"\n```ruby\nclass Post\n  has_many :attachments, as: :parent\nend\n```\n{: data-line=\"2\"}\n\n```ruby\nclass Image\n  belongs_to :parent, polymorphic: true\nend\n```\n{: data-line=\"2\"}\n\nAnd in migrations:\n\n```ruby\ncreate_table :images do |t|\n  t.references :post, polymorphic: true\nend\n```\n{: data-line=\"2\"}\n\nValidation\n----------\n","h2":null},{"title":"Validation","elms":"\n```ruby\nclass Person < ActiveRecord::Base\n```\n{:.-setup}\n\n```ruby\n  # Presence\n  validates :name,     presence: true\n```\n{: data-line=\"2\"}\n\n```ruby\n  # Acceptance\n  validates :terms,    acceptance: true\n```\n\n```ruby\n  # Confirm\n  validates :email,    confirmation: true\n```\n\n```ruby\n  # Unique\n  validates :slug,     uniqueness: true\n  validates :slug,     uniqueness: { case_sensitive: false }\n  validates :holiday,  uniqueness: { scope: :year, message: 'yearly only' }\n```\n\n```ruby\n  # Format\n  validates :code,     format: /regex/\n  validates :code,     format: { with: /regex/ }\n```\n\n```ruby\n  # Length\n  validates :name,     length: { minimum: 2 }\n  validates :bio,      length: { maximum: 500 }\n  validates :password, length: { in: => 6..20 }\n  validates :number,   length: { is: => 6 }\n```\n\n```ruby\n  # Include/exclude\n  validates :gender,   inclusion: %w(male female)\n  validates :gender,   inclusion: { in: %w(male female) }\n  validates :lol,      exclusion: %w(xyz)\n```\n\n```ruby\n  # Numeric\n  validates :points,   numericality: true\n  validates :played,   numericality: { only_integer: true }\n  # ... greater_than, greater_than_or_equal_to,\n  # ... less_than, less_than_or_equal_to\n  # ... odd, even, equal_to\n```\n\n```ruby\n  # Validate the associated records to ensure they're valid as well\n  has_many :books\n  validates_associated :books\n```\n\n```ruby\n  # Length (full options)\n  validates :content, length: {\n    minimum:   300,\n    maximum:   400,\n    tokenizer: lambda { |str| str.scan(/\\w+/) },\n    too_short: \"must have at least %{count} words\",\n    too_long:  \"must have at most %{count} words\" }\n```\n\n```ruby\n  # Multiple\n  validates :login, :email, presence: true\n```\n\n```ruby\n  # Conditional\n  validates :description, presence: true, if: :published?\n  validates :description, presence: true, if: lambda { |obj| .. }\n```\n\n```ruby\n  validates :title, presence: true, on: :save   # :save | :create | :update\n```\n\n```ruby\nend\n```\n{: .-setup}\n","h2":null},{"title":"Custom validations","elms":"\n```ruby\nclass Person < ActiveRecord::Base\n  validate :foo_cant_be_nil\n\n  def foo_cant_be_nil\n    errors.add(:foo, 'cant be nil')  if foo.nil?\n  end\nend\n```\n{: data-line=\"2\"}\n","h2":null},{"title":"Errors","elms":"\n```ruby\nrecord.errors.valid?      # → false\nrecord.errors             # → { :name => [\"can't be blank\"] }\nrecord.errors.messages    # → { :name => [\"can't be blank\"] }\n```\n\n```ruby\nrecord.errors[:name].any?\n```\n\nOther API\n---------\n","h2":null},{"title":"Callbacks","elms":"\n * [Guides: callbacks](http://guides.rubyonrails.org/active_record_validations_callbacks.html)\n","h2":null},{"title":"Mass updates","elms":"\n ```ruby\n# Updates person id 15\nPerson.update 15, name: \"John\", age: 24\nPerson.update [1,2], [{name: \"John\"}, {name: \"foo\"}]\n```\n","h2":null},{"title":"Joining","elms":"\n```ruby\n# Basic joins\nStudent.joins(:schools).where(schools: { type: 'public' })\nStudent.joins(:schools).where('schools.type' => 'public' )\n```\n\n```ruby\n# Multiple associations\nArticle.joins(:category, :comments)\n```\n\n```ruby\n# Nested associations\nArticle.joins(comments: :guest)\n```\n\n```ruby\n# SQL\nAuthor.joins(\n  'INNER JOIN posts ' +\n  'ON posts.author_id = authors.id ' +\n  'AND posts.published = \"t\"'\n)\n```\n","h2":null},{"title":"Where interpolation","elms":"\n```ruby\nwhere('name = ?', 'John')\nwhere(['name = :name', { name: 'John' }])\n```\n","h2":null},{"title":"Serialize","elms":"\n```ruby\nclass User < ActiveRecord::Base\n  serialize :preferences\nend\n```\n{: data-line=\"2\"}\n\n```ruby\nuser = User.create(\n  preferences: {\n    'background' => 'black',\n    'display' => 'large'\n  }\n)\n```\n\nYou can also specify a class option as the second parameter that’ll raise an \nexception if a serialized object is retrieved as a descendant of a class not in \nthe hierarchy.\n\n```ruby\n# Only Hash allowed!\nclass User < ActiveRecord::Base\n  serialize :preferences, Hash\nend\n```\n{: data-line=\"3\"}\n\n```ruby\n# Reading it raises SerializationTypeMismatch\nuser = User.create(preferences: %w(one two three))\nUser.find(user.id).preferences\n```\n\nOther tricks\n------------\n","h2":null},{"title":"Overriding accessors","elms":"\n```ruby\nclass Song < ActiveRecord::Base\n  # Uses an integer of seconds to hold the length of the song\n\n  def length=(minutes)\n    write_attribute(:length, minutes.to_i * 60)\n  end\n\n  def length\n    read_attribute(:length) / 60\n  end\nend\n```\n{: data-line=\"4,8\"}\n\nSee: <http://api.rubyonrails.org/classes/ActiveRecord/Base.html>\n\nCallbacks\n---------\n\n- after_create\n- after_initialize\n- after_validation\n- after_save\n- after_commit","h2":null}]}