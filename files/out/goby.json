{"head":{"title":"Goby","layout":"2017/sheet","prism_languages":["ruby"],"weight":-3,"updated":"2018-12-06T00:00:00.000Z","category":"Ruby","intro":"Goby's language design is based on Ruby language's, slim and shaped up. Differences in syntax between them is very small.\n"},"body":[{"title":"Hello world","elms":"{: .-prime}\n\n#### hello.gb\n{: .-file}\n\n```ruby\nclass Greet\n  attr_accessor :audience, :head, :tail\n  \n  def initialize\n    @head = \"Hello, \"\n    @tail = \"!\"\n  end\n\n  def name\n    audience.name\n  end\n\n  def say\n    puts head + name + tail\n  end\nend\n\nmodule MyName\n  attr_reader :name\n\n  def initialize\n    @name = self.class.to_s\n  end\nend\n\nclass World\n  include MyName\nend\n\ngreet = Greet.new\ngreet.audience = World.new\ngreet.say\n```\n\nThen run:\n\n```bash\n$ goby hello.gb\n#=> Hello, World!\n```\n","h2":"Getting started"},{"title":"REPL (igb)","elms":"\n```bash\n$ goby -i\n```\n\n* `reset`: reset the VM\n* `exit`: exit REPL\n* `help`: show help\n* ctrl-c: cancel the block entered, or exit (on top level)\n\nSee [igb manual & test script](https://github.com/goby-lang/goby/blob/master/igb/manual_test.md). You can use `readline` features such as command history by arrow keys.\n","h2":"Getting started"},{"title":null,"elms":"{: .-three-column}\n","h2":"Variables"},{"title":"Local variable","elms":"\n```ruby\nzip101 = \"233-7383\"\nmagic_number = 42\n```\n\nShould be \"`[a-z][a-z0-9_]+`\"(snake_case).\n","h2":"Variables"},{"title":"Instance variable","elms":"\n```ruby\nmodule State\n  def initialize(state)\n    @state = state      # declaring an instance variable by assignment\n  end\n  def show\n    @state              # accessible from other instance methods\n  end\nend\n\nstate = State.new \"success\"\nstate.show\n#=> success\n```\n\nShould be \"`@[a-z][a-z0-9_]+`\"(snake_case).\n","h2":"Variables"},{"title":"Multiple assignment","elms":"\n```ruby\n# array literal\na, b, c = [1, 2, 3]\n\n# array with '*'\na = [1, 2, 3]\nx, y, z = *a\n\n# array literal with '*'\na, b, c = *[1, 2, 3]\n\n# bare assignment: unsupported\na, b, c = 1, 2, 3  #=> unexpected 3 Line: 0\n```\n","h2":"Variables"},{"title":"Black hole variable","elms":"\n```ruby\n# '_' is write-only\na, _ = [1, 2]\n```\n","h2":"Variables"},{"title":"Class variable","elms":"\nUnsupported.\n","h2":"Variables"},{"title":"Global variable","elms":"\nUnsupported.\n","h2":"Variables"},{"title":"Method definition and calling","elms":"\n```ruby\ndef foo_bar?(baz)\n  if baz == \"Hi, Goby!\"\n    true\n  else\n    false\n  end\nend\n\nfoo_bar? \"Hi, Goby!\" #=> true\n```\n\nMethod name should be \"`[a-z][a-z0-9_]+\\??`\" (snake_case). You can omit the trailing \"`()`\" only if no parameters are taken. Trailing using \"`!`\" is **unsupported**.\n","h2":"Method definition"},{"title":"Order of method parameter","elms":"\n```ruby\ndef foo(normal, default=\"value\", hash={}, ary=[], keyword:, keyword_default:\"key\", *sprat)\nend\n```\n\nIf a default value is provided to a parameter, the parameter can be omitted when calling. `()` can be omitted. The order of parameters in method definition is restricted as follows:\n\n1. **normal parameters** (like `a`)\n2. **normal parameters with default value** (like `a=1`)\n3. **optional parameters** (array or hash, like `ary=[]` or `hs={}`)\n4. **keyword parameters** (like `kwd:`) \n5. **keyword parameters with default value** (like `kwd: 1` or `ary: [1,2,3]` or `hsh: {key: \"value\"}`)\n6. **splat parameters** (like `*sp`)\n\nOr you will receive an error.\n","h2":"Method definition"},{"title":"Keyword parameter (WIP)","elms":"\n```ruby\ndef foo(process:, verb: :GET, opt:{ csp: :enabled }, ary: [1, 2, 3])\nend\n```\n","h2":"Method definition"},{"title":"Returning value","elms":"\n```ruby\nPI = 3.14\ndef area(radius)\n  radius * PI      # returns the result of evaluation\nend\n\narea 6             #=> 18.84\n```\n","h2":"Method definition"},{"title":"Returning multiple value","elms":"\n```ruby\ndef my_array\n  [1, 2, 3]\nend\n\nmy_array   #=> [1, 2, 3]\n```\n","h2":"Method definition"},{"title":"Instance method","elms":"\n```ruby\nmodule Foo\n  def bar       # defining instance method\n    puts \"bar\"\n  end\n  \n  def baz(count, email: \"goby@example.com\")\n    count.times do\n      puts email\n    end\n  end\nend\n\nfoo = Foo.new\nfoo.bar     #=> bar\nfoo.baz(3)  #↓\ngoby@example.com\ngoby@example.com\ngoby@example.com\n```\n","h2":"Method definition"},{"title":"Singleton method #1","elms":"\n```ruby\nstr = \"Goby\"\ndef str.foo     #1 singleton method on the object\n  self * 2\nend\n\nstr.foo\n#=> GobyGoby\n```\n","h2":"Method definition"},{"title":"Singleton method #2","elms":"\n```ruby\nmodule Foo\n  def self.bar  #2 singleton method with `self.`\n    92\n  end\nend\n```\n","h2":"Method definition"},{"title":"Singleton method #3","elms":"\n```ruby\nmodule Foo  \n  def Foo.bar   #3 singleton method with a class name (unrecommended)\n    88\n  end\nend\n```\n","h2":"Method definition"},{"title":"Singleton method #4","elms":"\n```ruby\nmodule Foo end\n\ndef Foo.bar     #4 singleton methods outside the Foo\n  9999\nend\n\nFoo.bar #=> 9999\n```\n","h2":"Method definition"},{"title":"Attribute accessor method","elms":"\n```ruby\nclass Foo\n  attr_accessor :bar, :baz\n\n  def initialize\n    @bar = 42\n    @baz = 99\n  end\nend\n\nfoo = Foo.new\n\nfoo.bar = 77\nfoo.baz = 88\n```\n\nYou can use the following shorthands to declare attribute accessor methods in classes/modules:\n\n* `attr_accessor`\n* `attr_reader`\n* `attr_writer`\n","h2":"Method definition"},{"title":"Private method (to be implemented)","elms":"\n```ruby\nclass Foo\n  def bar\n    42\n  end\n  \n  def _baz  # leading '_' means private method\n    99\n  end\nend\n```\n","h2":"Method definition"},{"title":null,"elms":"{: .-three-column}\n","h2":"Module/Class definition"},{"title":"Module definition and `include`","elms":"\n```ruby\nmodule Foo\n  def foo\n    \"Foo's instance method\"\n  end\nend\n\nclass Bar\n  include Foo   # to include Foo\nend\n\nBar.new.foo     #=> Foo's instance method\n```\n\nModule names should be \"`[A-Z][A-Za-z0-9_]+`\" (UpperCamelCase). Modules cannot be inherited.\n","h2":"Module/Class definition"},{"title":"Module definition and `extend`","elms":"\n```ruby\nmodule Foo\n  def foo\n    \"Foo's instance method will be a singleton method\"\n  end\nend\n\nclass Bar\n  extend Foo   # to extend Foo  \nend\n\nBar.foo        #=> Foo's instance method will be a singleton method\n```\n\n`extend` is to use the instance methods in the specified modules as **singleton methods** in your class or module. \n","h2":"Module/Class definition"},{"title":"Module instantiation","elms":"\n```ruby\nmodule Foo   #module definition\n  def foo   \n    99\n  end\nend\n\nFoo.new.foo  #=> 99\n```\n\nActually, Goby's module can be even **instantiated** via \"`new`\" like \"`Foo.new`\".\n","h2":"Module/Class definition"},{"title":"Class definition and inheritance","elms":"\n```ruby\nclass Foo       # class definition\n  def bar\n    99\n  end\nend\n\nclass Baz < Foo # inheritance\nend\n\nBaz.new.bar  #=> 99\n```\n\nClass names should be \"`[A-Z][A-Za-z0-9]+`\" (UpperCamelCase). Inheritance with \"`<`\" is supported.\n","h2":"Module/Class definition"},{"title":"Constants","elms":"\n```ruby\nHTTP_ERROR_404 = 404\nHTTP_ERROR_404 = 500    # error\n```\n\nConstants should be \"`[A-Z][A-Za-z0-9_]+`\" (UPPER_SNAKECASE). Constants are **not reentrant** and the scope is **global**.\n","h2":"Module/Class definition"},{"title":"Redefining class/modules","elms":"\n```ruby\nclass Foo\n  def bar\n    99\n  end\nend\n\nclass Foo\n  def bar  # redefining is possible\n    77\n  end\nend\n```\n","h2":"Module/Class definition"},{"title":"Namespaces","elms":"\n```ruby\nclass Foo\n  module Bar\n    MAGIC = 99\n    def baz\n      99\n    end\n  end\nend\n\nFoo::Bar.new.baz     # Use '::' for namespacing\nFoo::Bar::MAGIC      # Use '::' for namespacing\n```\n","h2":"Module/Class definition"},{"title":"`require`","elms":"\n```ruby\nrequire(\"uri\")   # to activate URL class\n\nu = URI.parse(\"http://example.com\")\nu.scheme   #=> \"http\"\n```\t\n","h2":"Load library"},{"title":"`require_relative`","elms":"\n```ruby\nrequire_relative(\"bar\")  # loading the local bar.gb\n\nclass Foo\n  def self.bar(x)\n    Bar.foo do |ten|\n      x * ten\n    end\n  end\n\n  def self.baz\n    yield(100)\n  end\nend\n```\n","h2":"Load library"},{"title":null,"elms":"{: .-three-column}\n","h2":"Literal"},{"title":"Keyword","elms":"\n`def`, `true`, `false`, `nil`, `if`, `elsif`, `else`, `case`, `when`, `return`, `self`, `end`, `while`, `do`, `yield`, `get_block`, `next`, `class`, `module`, `break`\n","h2":"Literal"},{"title":"String literal","elms":"\n```ruby\n\"double quote\"\n'single quote'\n```\n\nDouble and single quotation can be used.\n","h2":"Literal"},{"title":"Symbol literal","elms":"\n```ruby\n:symbol           # equivalent to \"symbol\"\n{ symbol: \"value\" }\n```\n\nGoby's symbol (using `:`) is always `String` class.\n","h2":"Literal"},{"title":"Numeric literal","elms":"\n```ruby\nyear   =  2018   # Integer\noffset = -42     # Integer\nPI     = 3.14    # Float\nG      = -9.8    # Float\n```\n","h2":"Literal"},{"title":"Array literal","elms":"\n```ruby\n[1, 2, 3, \"hello\", :goby, { key: \"value\"}]\n[1, 2, [3, 4], 5, 6]\n```\n","h2":"Literal"},{"title":"Hash literal","elms":"\n```ruby\nh = { key: \"value\", key2: \"value2\" }\nh[:key2]   #=> value2\n```\n\nHash literal's keys should always be **symbol literals**. \n","h2":"Literal"},{"title":"Range literal","elms":"\n```ruby\n(1..10).each do |x|    # '..' represents a range\n  puts x*x\nend\n```\n","h2":"Literal"},{"title":"Boolean and `nil`","elms":"\n```ruby\ntrue       # Boolean class\nfalse      # Boolean class\nnil        # Null class\n\n!nil  #=> true\n```\n\nAny objects except `nil` and `false` will be treated as `true` on conditionals.\n","h2":"Literal"},{"title":"Arithmetic/logical/assignment operators","elms":"\n```ruby\n+           # unary\n**          # power\n-           # unary\n* / %       # multiplication, division, modulus\n+ -         # addition, subtraction\n!           # logical inversion\n> >= < <=   # inequality comparison\n== !=       # equality comparison, negative comparison\n&&          # logical AND\n||          # logical OR\n+= -=       # shorthand of addition/subtraction\n=           # assignment\n```\n\n*Priority of operators are TBD\n","h2":"Operator"},{"title":"Other operators","elms":"\n```ruby\n()          # chaning priority of interpretation\n[]          # array literal\n*           # multiple assignment\n..          # range\n```\n\n*Priority of operators are TBD\n","h2":"Operator"},{"title":"Delimiter","elms":"\n```ruby\nclass Foo; end   # ';' to delimit\n\nclass Bar end    # recommended\n```\n","h2":"Operator"},{"title":"String interpolation (to be implemented)","elms":"\n```ruby\nputs \"Error: #{error_message}\"  # double quotation is required\n```\n","h2":"Operator"},{"title":"Comment","elms":"\n```ruby\nputs \"Goby\"    # comments\n```\n\nUse the annotations to keep the comments concise.\n\n- `TODO`\n- `FIXME`\n- `OPTIMIZE`\n- `HACK`\n- `REVIEW`\n","h2":"Operator"},{"title":"I/O","elms":"\n* `#puts`\n\n* special constants: `ARGV`, `STDIN`, `STDOUT`, `STDERR`, `ENV` \n","h2":"Operator"},{"title":null,"elms":"{: .-three-column}\n","h2":"Flow control"},{"title":"`if`, `else`, `elsif`","elms":"\n```ruby\ndef foo(str)\n  if str.size > 10\n    puts \"too big!\"\n  elsif str.size < 3\n    puts \"too short!\"\n  else\n    puts \"moderate\"\n  end\nend\n```\n\n`then` is **not** supported.\n","h2":"Flow control"},{"title":"Break","elms":"\n```ruby\ndef foo(tail)\n  (5..tail).each do |t|\n    if t % 2 == 0 && t % 5 == 0\n      puts \"ouch!\"\n      break       # finish the block\n    else\n      puts t\n    end\n  end\n  puts \"out of the block\"\nend\n\nfoo 20\n#=> 5 6 7 8 9\n#=> ouch!\n#=> out of the block\n```\n","h2":"Flow control"},{"title":"Case","elms":"\n```ruby\ndef foo(str)\n  case str\n  when \"Elf\"\n    puts \"You might be Aragorn II!\"\n  when \"Aragorn\"\n    puts \"Long time no see, Aragorn!\"\n  when \"Frodo\", \"Sam\", \"Gandalf\"\n    puts \"One of us!\"\n  else\n    puts \"You're not yourself\"\n  end\nend\n```\n","h2":"Flow control"},{"title":"While","elms":"\n```ruby\ndecr = 10\nwhile decr do\n  if decr < 1\n    break\n  end\n  puts decr\n  decr -= 1\nend\n```\n\n`while`, conditional and a `do`/`end` block can be used for a loop.\n","h2":"Flow control"},{"title":"Rescue","elms":"\nUnder construction. Join [#605](https://github.com/goby-lang/goby/issues/605).\n","h2":"Flow control"},{"title":null,"elms":"{: .-three-column}\n","h2":"Block"},{"title":"Block","elms":"\n```ruby\ndef foo(ary: [1, 2, 3])\n  ary.each do |s|      # start of the block with |block variable|\n    puts s\n  end                  # end of the block\nend\n```\n\n`{ }` cannot be used for forming a block.\n","h2":"Block"},{"title":"`yield`","elms":"\n```ruby\ndef foo\n  yield(10)  # executes the block given\nend\n\nfoo do |ten|\n  ten + 20\nend\n```\n","h2":"Block"},{"title":"Block object and `call`","elms":"\n```ruby\nb = Block.new do\n  100\nend\n\nb.call  #=> 100\n```\n\n`Block.new` can take a block and then `call`.\n","h2":"Block"},{"title":"Passing a block","elms":"\n```ruby\ndef baz\n  1000\nend\n\nclass Foo\n  def exec_block(block)\n\tblock.call\n  end\n\n  def baz\n    100\n  end\nend\n\nb = Block.new do\n  baz\nend\n\nf = Foo.new\nf.exec_block(b)\n```\n","h2":"Block"},{"title":"Passing a block with block arguments","elms":"\n```ruby\nb = Block.new do |arg, offset|\n  arg + 1000 - offset\nend\n\nb.call(49, 500) #=> 549\n```\n","h2":"Block"},{"title":"Special `get_block` keyword","elms":"\n```ruby\ndef bar(block)\n  # runs the block object and the block arg simultaneously\n  block.call + get_block.call\nend\n\ndef foo\n  bar(get_block) do # passes two blocks to `bar`\n    20\n  end\nend\n\nfoo do\n  10\nend\n```\n\n`get_block` is not a method but a **keyword** to retrive a given block argument as a block object. By this, you can pass around or `call` the given block arguments as block objects. \n","h2":"Block"},{"title":"Closure","elms":"\n```ruby\ncount = 0          # the declaration is used\nb = Block.new do\n  count += 1       # the block looks preserving the `count`\nend\n\nclass Foo\n  def bar(blk)\n    count = 9      # (does not affect)\n    puts blk.call  # local variable is resolved to the one above\n  end\nend\n\nFoo.new.bar b  #=> 1\nFoo.new.bar b  #=> 2\nFoo.new.bar b  #=> 3\n```\n","h2":"Block"},{"title":null,"elms":"{: .-three-column}\n\nGoby's most \"native\" classes cannot instantiate with `new` in principle. \n","h2":"Native class (Primary)"},{"title":"`Object`","elms":"\n```ruby\nBar.ancestors\n#» [Bar, Foo, Object]\nBar.singleton_class.ancestors\n#» [#<Class:Bar>, #<Class:Object>, Class, Object]\n```\n\n`Object` is actually just for creating singleton classes. See `Class`.\n\n* **`Object.methods`**: `!`, `!=`, `==`, `block_given?`, `class`, `exit`, `instance_eval`, `instance_variable_get`, `instance_variable_set`, `is_a?`, `methods`, `nil?`, `object_id`, `puts`, `raise`, `require`, `require_relative`, `send`, `singleton_class`, `sleep`, `thread`, `to_s`, `<`, `<=`, `>`, `>=`, `ancestors`, `attr_accessor`, `attr_reader`, `attr_writer`, `extend`, `include`, `name`, `new`, `superclass`\n\n* **`Object.new.methods`**: `!`, `!=`, `==`, `block_given?`, `class`, `exit`, `instance_eval`, `instance_variable_get`, `instance_variable_set`, `is_a?`, `methods`, `nil?`, `object_id`, `puts`, `raise`, `require`, `require_relative`, `send`, `singleton_class`, `sleep`, `thread`, `to_s`\n","h2":"Native class (Primary)"},{"title":"`Class`","elms":"\n```ruby\nString.ancestors      #=> [String, Object]\n```\n\n`Class` and `Object`can actually be regarded as the same and you don't need to distinguish them in almost all the cases. \n\n* **`Class.methods`**: `<`, `<=`, `>`, `>=`, `ancestors`, `attr_accessor`, `attr_reader`, `attr_writer`, `extend`, `include`, `name`, `new`, `superclass`, `!`, `!=`, `==`, `block_given?`, `class`, `exit`, `instance_eval`, `instance_variable_get`, `instance_variable_set`, `is_a?`, `methods`, `nil?`, `object_id`, `puts`, `raise`, `require`, `require_relative`, `send`, `singleton_class`, `sleep`, `thread`, `to_s`\n","h2":"Native class (Primary)"},{"title":"`String`","elms":"\n```ruby\nputs \"Hello\" + ' ' + 'world'  #=> Hello world\n```\n\nFixed to **UTF-8** with mb4 support.\n\n* **`String.methods`**: `fmt`,\n    * the rest: `Class.methods`\n* **`\"a\".methods`**:  `!=`, `*`, `+`, `<`, `<=>`, `==`, `=~`, `>`, `[]`, `[]=`, `capitalize`, `chop`, `concat`, `count`, `delete`, `downcase`, `each_byte`, `each_char`, `each_line`, `empty?`, `end_with?`, `eql?`, `fmt`, `include?`, `insert`, `length`, `ljust`, `match`, `new`, `replace`, `replace_once`, `reverse`, `rjust`, `size`, `slice`, `split`, `start_with`, `strip`, `to_a`, `to_bytes`, `to_d`, `to_f`, `to_i`, `to_s`, `upcase`,\n    * the rest: `Object.new.methods`\n","h2":"Native class (Primary)"},{"title":"`Integer`","elms":"\n```ruby\n37037 * 27      #=> 999999\n```\n\n* **`Integer.methods`**: the same as `Class.methods`\n* **`1.methods`**: `!=`, `%`, `*`, `**`, `+`, `-`, `/`, `<`, `<=`, `<=>`, `==`, `>`, `>=`, `even?`, `new`, `next`, `odd?`, `pred`, `ptr`, `times`, `to_f`, `to_float32`, `to_float64`, `to_i`, `to_int`, `to_int16`, `to_int32`, `to_int64`, `to_int8`, `to_s`, `to_uint`, `to_uint16`, `to_uint32`, `to_uint64`, `to_uint8`\n    * the rest: `Object.new.methods`\n","h2":"Native class (Primary)"},{"title":"`Array`","elms":"\n```ruby\n[1, \"2\", :card, [4, 5], { john: \"doe\" }]\n```\n\n* **`Array.methods`**: the same as `Class.methods`\n* **`[1].methods`**: `*`, `+`, `[]`, `[]=`, `any?`, `at`, `clear`, `concat`, `count`, `delete_at`, `dig`, `each`, `each_index`, `empty?`, `first`, `flatten`, `include?`, `join`, `last`, `lazy`, `length`, `map`, `new`, `pop`, `push`, `reduce`, `reverse`, `reverse_each`, `rotate`, `select`, `shift`, `to_enum`, `unshift`, `values_at`\n    * the rest: `Object.new.methods`\n","h2":"Native class (Primary)"},{"title":"`Hash`","elms":"\n```ruby\nh = { key: \"value\" }\nh = { \"key\": \"value\" }  #=> error\n\nh[\"key\"]  #=> value\nh[:key]   #=> value\n```\n\nKeys in hash literals should be **symbol literals**, while Hash index can be either string or symbol literals.\n\n* **`Hash.methods`**: the same as `Class.methods`\n* **`{ key: \"value\" }.methods`**: `[]`, `[]=`, `any?`, `clear`, `default`, `default=`, `delete`, `delete_if`, `dig`, `each`, `each_key`, `each_value`, `empty?`, `eql?`, `fetch`, `fetch_values`, `has_key?`, `has_value?`, `keys`, `length`, `map_values`, `merge`, `new`, `select`, `sorted_keys`, `to_a`, `to_json`, `to_s`, `transform_values`, `values`, `values_at`\n    * the rest: `Object.new.methods`\n","h2":"Native class (Primary)"},{"title":"`Range`","elms":"\n```ruby\n(1..10).each do |i|\n  puts i ** 2\nend\n```\n\n* **`Range.methods`**: the same as `Class.methods`\n* **`(1..10).methods`**: `!=`, `==`, `bsearch`, `each`, `first`, `include?`, `last`, `lazy`, `map`, `new`, `size`, `step`, `to_a`, `to_enum`\n    * the rest: `Object.new.methods`\n","h2":"Native class (Primary)"},{"title":"`Block`","elms":"\n```ruby\nb = Block.new do\n  100\nend\n\nb.call  #=> 100\n```\n\n* **`Block.methods`**: the same as `Class.methods`\n* **`(Block.new do end).methods`**: `call`\n    * the rest: `Object.new.methods`\n","h2":"Native class (Primary)"},{"title":null,"elms":"{: .-three-column}\n","h2":"Native class (secondary)"},{"title":"`Float`","elms":"\n```ruby\n1.1 + 1.1   # => -2.2\n2.1 * -2.1  # => -4.41\n```\n\nFloat literals like `3.14` or `-273.15`. `Float` class is based on Golang's `float64` type.\n\n* **`Float.methods`**: the same as `Class.methods`\n* **`3.14.methods`**: `!=`, `%`, `*`, `**`, `+`, `-`, `/`, `<`, `<=`, `<=>`, `==`, `>`, `>=`, `new`, `ptr`, `to_d`, `to_i`\n    * the rest: `Object.new.methods`\n","h2":"Native class (secondary)"},{"title":"`Decimal`","elms":"\n```ruby\n\"3.14\".to_d            # => 3.14\n\"-0.7238943\".to_d      # => -0.7238943\n\"355/113\".to_d         \n# => 3.1415929203539823008849557522123893805309734513274336283185840\n\na = \"16.1\".to_d\nb = \"1.1\".to_d\ne = \"17.2\".to_d\na + b # => 0.1\na + b == e # => true\n\n('16.1'.to_d  + \"1.1\".to_d).to_s #=> 17.2\n('16.1'.to_f  + \"1.1\".to_f).to_s #=> 17.200000000000003\n```\n\nExperimental: the size is arbitrary and internally a fraction from Golang's `big.Rat` type. Decimal literal is TBD for now and you can get `Decimal` number via `to_d` method from `Integer`/`Float`/`String`.\n\n* **`Decimal.methods`**: the same as `Class.methods`\n* **`(1.1).to_d.methods`**: `!=`, `*`, `**`, `+`, `-`, `/`, `<`, `<=`, `<=>`, `==`, `>`, `>=`, `denominator`, `fraction`, `inverse`\n    * the rest: `Object.new.methods`\n","h2":"Native class (secondary)"},{"title":"`Regexp`","elms":"\n```ruby\na = Regexp.new(\"orl\")\na.match?(\"Hello World\")   #=> true\na.match?(\"Hello Regexp\")  #=> false\n\nb = Regexp.new(\"😏\")\nb.match?(\"🤡 😏 😐\")    #=> true\nb.match?(\"😝 😍 😊\")    #=> false\n\nc = Regexp.new(\"居(ら(?=れ)|さ(?=せ)|る|ろ|れ(?=[ばる])|よ|(?=な[いかくけそ]|ま[しすせ]|そう|た|て))\")\nc.match?(\"居られればいいのに\")  #=> true\nc.match?(\"居ずまいを正す\")      #=> false\n```\n\nUsing `/ /` is to be implemented.\n\n* **`Regexp.methods`**: the same as `Class.methods`\n* **`Regexp.new(\"^aa$\").methods`**: `==`, `match?`\n    * the rest: `Object.new.methods`\n","h2":"Native class (secondary)"},{"title":"`MatchData`","elms":"\n```ruby\n# numbered capture\n'abcd'.match(Regexp.new('(b.)'))\n#=> #<MatchData 0:\"bc\" 1:\"bc\">\n\n# named capture\n'abcd'.match(Regexp.new('a(?<first>b)(?<second>c)'))\n#=> #<MatchData 0:\"abc\" first:\"b\" second:\"c\">\n\n# converting to hash\n» 'abcd'.match(Regexp.new('a(?<first>b)(?<second>c)')).to_h\n#» { 0: \"abc\", first: \"b\", second: \"c\" }\n```\n\nThe number keys in the captures are actually `String` class.The key `0` is the mached string.\n\n* **`MatchData.methods`**: the same as `Class.methods`\n* **`'abcd'.match(Regexp.new('(b.)')).methods`**: `captures`, `length`, `new`, `to_a`, `to_h`\n    * the rest: `Object.new.methods`\n","h2":"Native class (secondary)"},{"title":"`File`","elms":"\n```ruby\nf = File.new(\"../test_fixtures/file_test/size.gb\")\nf.name  #=> \"../test_fixtures/file_test/size.gb\"\n```\n\n* **`File.methods`**: `basename`, `chmod`, `delete`, `exist?`, `extname`, `join`\n    * the rest: `Class.methods`\n* **`File.new.methods`**: `basename`, `chmod`, `close`, `delete`, `exist?`, `extname`, `join`, `name`\n    * the rest: `Object.new.methods`\n","h2":"Native class (secondary)"},{"title":null,"elms":"{: .-three-column}\n","h2":"Native class (Golang-oriented)"},{"title":"`GoMap`","elms":"\n```ruby\nh = { foo: \"bar\" }\nm = GoMap.new(h)    # to pass values to Golang's code\nh2 = m.to_hash\nh2[:foo]   #=> \"bar\"\n```\n\n* **`GoMap.methods`**: the same as `Class.methods`\n* **`GoMap.new.methods`**: `get`, `set`, `to_hash`\n    * the rest: `Object.new.methods`\n","h2":"Native class (Golang-oriented)"},{"title":"`Channel`","elms":"\n```ruby\nc = Channel.new\n\n1001.times do |i| # i start from 0 to 1000\n  thread do\n  \tc.deliver(i)\n  end\nend\n\nr = 0\n1001.times do\n  r = r + c.receive\nend\n\nr #=> 500500\n```\n\n`Channel` class is to hold channels to work with `#thread`. See `thread`.\n\n* **`Channel.methods`**: the same as `Class.methods`\n* **`Channel.new.methods`**: `close`, `deliver`, `new`, `receive`\n    * the rest: `Object.new.methods`\n","h2":"Native class (Golang-oriented)"},{"title":null,"elms":"\nPretty new experimental library.\n","h2":"Enumerator & lazy"},{"title":"`LazyEnumerator`","elms":"\n```ruby\n# creating a lazy enumerator\nenumerator = LazyEnumerator.new(ArrayEnumerator.new([1, 2, 3])) do |value|\n\t2 * value\nend\nresult = []\n\nenumerator.each do |value|\n\tresult.push(value)\nend\n\nresult   #=> [2, 4, 6]\n```\n\nA shorthand `#lazy` method is also provided in `Array` and `Range` by now. See \"Tips & tricks\" below. \n\n* **`LazyEnumerator.methods`**: the same as `Class.methods`\n* **`[1, 2].lazy`**: `each`, `first`, `has_next?`, `initialize`, `map`, `next`\n    * the rest: `Object.new.methods`\n","h2":"Enumerator & lazy"},{"title":"`ArrayEnumerator`","elms":"\n```ruby\niterated_values = []\n\nenumerator = ArrayEnumerator.new([1, 2, 4])\n\nwhile enumerator.has_next? do\n\titerated_values.push(enumerator.next)\nend\n\niterated_values   #=> [1, 2, 4]\n```\n\n* **`ArrayEnumerator.methods`**: the same as `Class.methods`\n* **`ArrayEnumerator.new([1, 2, 3]).methods`**: `has_next?`, `initialize`, `next`\n    * the rest: `Object.new.methods`\n","h2":"Enumerator & lazy"},{"title":"`RangeEnumerator`","elms":"\n```ruby\niterated_values = []\n\nenumerator = RangeEnumerator.new((1..4))\n\nwhile enumerator.has_next? do\n\titerated_values.push(enumerator.next)\nend\n\niterated_values   #=> [1, 2, 3, 4]\n```\n\n* **`RangeEnumerator.methods`**: the same as `Class.methods`\n* **`RangeEnumerator.new(1..2).methods`**: `has_next?`, `initialize`, `next`\n    * the rest: `Object.new.methods`\n","h2":"Enumerator & lazy"},{"title":"`Boolean`","elms":"\n```ruby\ntrue.class  #=> Boolean\nfalse.class #=> Boolean\n```\n\nA special class that just to hold `true` and `false`. Cannot be instantiate.\n","h2":"Special class"},{"title":"`Null`","elms":"\n```ruby\nnil.class   #=> Null\n```\n\nA special class that just to hold `nil`. Cannot be instantiate.\n","h2":"Special class"},{"title":"`Method`","elms":"\n(A special dummy class that just holds methods defined by Goby code.)\n","h2":"Special class"},{"title":"`Diggable`","elms":"\nProvides `#dig` method. Currently. `Array` and `Hash` classes' instance can be `Diggable`.\n\n```ruby\n[1, 2].dig(0, 1)  #=> TypeError: Expect target to be Diggable, got Integer\n```\n","h2":"Special class"},{"title":"`Spec`","elms":"\n```ruby\nrequire \"spec\"\n\nSpec.describe Spec do\n  it \"fails and exit with code 1\" do\n\texpect(1).to eq(2)\n  end\nend\n\nSpec.run\n```\n\n* **`Spec.methods`**: `describe`, `describes`, `instance`, `run`\n    * the rest: `Object.methods`\n* **`Spec.new.methods`**: `describes`, `initialize`, `run`, `session_successful`, `session_successful=`\n    * the rest: `Hash.new.methods`\n","h2":"Testing framework"},{"title":"Showing methods","elms":"\n```ruby\n» \"string\".methods\n#» [\"!=\", \"*\", \"+\", \"<\", \"<=>\", \"==\", \"=~\", \">\", \"[]\", \"[]=\", \"capitalize\", \"chop\", \"concat\", \"count\", \"delete\", \"downcase\", \"each_byte\", \"each_char\", \"each_line\", \"empty?\", \"end_with?\", \"eql?\", \"fmt\", \"include?\", \"insert\", \"length\", \"ljust\", \"match\", \"new\", \"replace\", \"replace_once\", \"reverse\", \"rjust\", \"size\", \"slice\", \"split\", \"start_with\", \"strip\", \"to_a\", \"to_bytes\", \"to_d\", \"to_f\", \"to_i\", \"to_s\", \"upcase\", \"!\", \"block_given?\", \"class\", \"exit\", \"instance_eval\", \"instance_variable_get\", \"instance_variable_set\", \"is_a?\", \"methods\", \"nil?\", \"object_id\", \"puts\", \"raise\", \"require\", \"require_relative\", \"send\", \"singleton_class\", \"sleep\", \"thread\"]\n```\n","h2":"Tips & tricks"},{"title":"Showing class","elms":"\n```ruby\n» \"string\".class\n#» String\n```\n","h2":"Tips & tricks"},{"title":"Showing singleton class","elms":"\n```ruby\n» \"moji\".singleton_class\n#» #<Class:#<String:842352325152>>\n\n» \"moji\".class.singleton_class\n#» #<Class:String>\n```\n","h2":"Tips & tricks"},{"title":"Showing ancestors","elms":"\n```ruby\n» Integer.ancestors\n#» [Integer, Object]\n\n» \"moji\".class.ancestors\n#» [String, Object]\n```\n","h2":"Tips & tricks"},{"title":"Showing singleton classes' ancestors","elms":"\n```ruby\n» \"moji\".class.singleton_class.ancestors\n#» [#<Class:String>, #<Class:Object>, Class, Object]\n```\n","h2":"Tips & tricks"},{"title":"Showing object's id","elms":"\n```ruby\n» \"moji\".object_id\n#» 842352977920\n```\n","h2":"Tips & tricks"},{"title":"`#to_json`","elms":"\n```ruby\nh = { a: 1, b: [1, \"2\", [4, 5, nil]]}\nh.to_json         # converts hash to JSON\n#=> {\"a\":1, \"b\":[1, \"2\", [4, 5, null]]}\n```\n","h2":"Tips & tricks"},{"title":"Customize `#to_json`","elms":"\nOverwrite the `#to_json` in your class:\n\n```ruby\nclass JobTitle\n  def initialize(name)\n    @name = name\n  end\n\n  def to_json\n    { title: @name }.to_json\n  end\nend\n\nclass Person\n  def initialize(name, age)\n    @name = name\n    @age = age\n    @job = JobTitle.new(\"software engineer\")\n  end\n\n  def to_json\n    { name: @name, age: @age, job: @job }.to_json\n  end\nend\n\nstan = Person.new(\"Stan\", 23)\nh = { person: stan }\nh.to_json #=> {\"person\":{\"name\":\"Stan\",\"job\":{\"title\":\"software engineer\"},\"age\":23}}\n```\n","h2":"Tips & tricks"},{"title":"Lazy enumeration","elms":"\nTo avoid N + 1 query.\n\n```ruby\nenumerator = [1, 2, 3].lazy.map do |value|\n\t2 * value\nend\nresult = []\n\nenumerator.each do |value|\n\tresult.push(value)\nend\n\nresult  #=> [2, 4, 6]\n```\t\n\nYou can call `#lazy.map` on `Array`, `Range`, or `JSON` objects. \n","h2":"Tips & tricks"},{"title":"Quick style guide","elms":"\n* UTF-8 should be used.\n* Only two spaces `  ` should be used for one indentation.\n    * Tab cannot be used for indentation.\n* For more, follow [RuboCop's style guide](https://github.com/bbatsov/ruby-style-guide) in principle.\n","h2":"Styling"},{"title":"Document notation","elms":"\n* `Class#instance_method` -- use `#` to represent instance methods in documents\n* `Class.class_method`\n* `Module.module_method`\n","h2":"Styling"},{"title":"Syntax highlighting","elms":"\nReady for Vim and Sublime text. You can also use Ruby's syntax highlighting so far.\n","h2":"Styling"},{"title":"Official","elms":"\n* Official site: [https://goby-lang.org/](https://goby-lang.org/)\n* Repository: [https://github.com/goby-lang/goby/](https://github.com/goby-lang/goby/)\n* DevHints: [https://devhints.io/goby](https://devhints.io/goby) (this page)\n","h2":"References"},{"title":"Readings for Goby developers","elms":"\n* [Write an Interpreter in Go](https://interpreterbook.com/)\n* [Nand2Tetris II](https://www.coursera.org/learn/nand2tetris2/home/welcome)\n* [Ruby under a microscope](http://patshaughnessy.net/ruby-under-a-microscope)\n* [YARV's instruction table](http://www.atdot.net/yarv/insnstbl.html)\n","h2":"References"},{"title":"JP resource","elms":"\n* [Goby: Rubyライクな言語（1）Gobyを動かしてみる](https://techracho.bpsinc.jp/hachi8833/2017_11_10/47787)\n* [Gobyの組み込みクラスにメソッドを追加する方法](https://qiita.com/hanachin_/items/efc1c976a4f5749514ef)","h2":"References"}]}