{"head":{"title":"StimulusReflex","category":"Ruby","layout":"2017/sheet","updated":"2021-01-07T00:00:00.000Z"},"body":[{"title":"via Data Attributes","elms":"\nTrigger reflexes without writing any javascript with the `data-reflex` attribute.\n\n```erb\n<!-- index.html.erb -->\n<a\n  href=\"#\"\n  data-reflex=\"click->CounterReflex#increment\"\n  data-step=\"1\"\n  data-count=\"<%= @count.to_i %>\"\n  >Increment <%= @count.to_i %></a\n>\n```\n\n```ruby\n# counter_reflex.rb\nclass CounterReflex < StimulusReflex::Reflex\n  def increment\n    @count = element.dataset[:count].to_i + element.dataset[:step].to_i\n  end\nend\n```\n","h2":null},{"title":"from Stimulus.js Controller","elms":"\nStimulus.js controllers registered with StimulusReflex can use the `stimulate` method to trigger reflexes\n\n```erb\n<!-- index.html.erb -->\n<a href=\"#\"\n  data-controller=\"counter\"\n  data-action=\"click->counter#increment\"\n>Increment <%= @count %></a>\n```\n\n```javascript\n// counter_controller.js\nimport { Controller } from 'stimulus'\nimport StimulusReflex from 'stimulus_reflex'\n\nexport default class extends Controller {\n  connect() {\n    StimulusReflex.register(this)\n  }\n\n  increment(event) {\n    event.preventDefault()\n    this.stimulate('Counter#increment', 1)\n  }\n}\n```\n\n```ruby\n# counter_reflex.rb\nclass CounterReflex < StimulusReflex::Reflex\n  def increment(step = 1)\n    session[:count] = session[:count].to_i + step\n   end\nend\n```\n","h2":null},{"title":"Selector morphs","elms":"\nInstead of refreshing the entire page, you can specify a portion of the page to update with `morph(selector, content)`\n\n```erb\n<!-- show.html.erb -->\n<header data-reflex=\"click->Example#change\">\n  <%= render partial: \"path/to/foo\", locals: {message: \"Am I the medium or the massage?\"} %>\n</header>\n```\n\n```erb\n<!-- _foo.html.erb -->\n<div id=\"foo\">\n  <span class=\"spa\"><%= message %></span>\n</div>\n```\n\n```ruby\n# example_reflex.rb\nclass ExampleReflex < ApplicationReflex\n  def change\n    morph \"#foo\", \"Your muscles... they are so tight.\"\n  end\nend\n```\n","h2":"Morphs"},{"title":"Nothing morph","elms":"\nUse `morph :nothing` in reflexes that do something on the server without updating the client.\n\n```ruby\n# example_reflex.rb\nclass ExampleReflex < ApplicationReflex\n  def change\n    LongRunningJob.perform_later\n    morph :nothing\n  end\nend\n```\n","h2":"Morphs"},{"title":"Server-side callbacks","elms":"\nReflex classes can use the following callbacks. [Full Docs](http://docs.stimulusreflex.com/lifecycle#server-side-reflex-callbacks)\n\n- `before_reflex`\n- `around_reflex`\n- `after_reflex`\n","h2":"Lifecycle"},{"title":"Client-side callbacks (generic)","elms":"\nStimulusReflex controllers automatically support five generic lifecycle callback methods.\n\n- `beforeReflex(element, reflex, noop, reflexId)` prior to sending a request over the web socket\n- `reflexSuccess(element, reflex, noop, reflexId)` after the server side Reflex succeeds and the DOM has been updated\n- `reflexError(element, reflex, error, reflexId)` whenever the server side Reflex raises an error\n- `reflexHalted(element, reflex, noop, reflexId)` reflex canceled with throw :abort in the before_reflex callback\n- `afterReflex(element, reflex, noop, reflexId)` after both success and error\n- `finalizeReflex(element, reflex, noop, reflexId)` after both success and error\n","h2":"Lifecycle"},{"title":"Client-side callbacks (custom)","elms":"\nStimulusReflex controllers can define up to five custom lifecycle callback methods for each Reflex action. These methods use a naming convention based on the name of the Reflex. e.g. for the `add_one` reflex:\n\n- `beforeAddOne(element, reflex, noop, reflexId)`\n- `addOneSuccess(element, reflex, noop, reflexId)`\n- `addOneError(element, reflex, error, reflexId)`\n- `addOneHalted(element, reflex, noop, reflexId)`\n- `afterAddOne(element, reflex, noop, reflexId)`\n- `finalizeAddOne(element, reflex, noop, reflexId)`\n","h2":"Lifecycle"},{"title":"Client-side events","elms":"\nIf you need to know when a Reflex method is called, but you're working outside of the Stimulus controller that initiated it, you can subscribe to receive DOM events\n\n- `stimulus-reflex:before`\n- `stimulus-reflex:success`\n- `stimulus-reflex:error`\n- `stimulus-reflex:halted`\n- `stimulus-reflex:after`\n\nThere are also events related to the StimulusReflex library setting up and connecting to ActionCable\n\n- `stimulus-reflex:connected`\n- `stimulus-reflex:disconnected`\n- `stimulus-reflex:rejected`\n- `stimulus-reflex:ready`\n","h2":"Lifecycle"},{"title":"Forms","elms":"\nIf a Reflex is called on a form element - or a child of that form element - then the data for the whole form will be properly serialized and made available to the Reflex action method as the `params` accessor. [Read more](http://docs.stimulusreflex.com/working-with-forms)\n","h2":"Helpful tips"},{"title":"Promises","elms":"\n`stimulate()` method returns a promise\n\n```javascript\nthis.stimulate('Comments#create')\n  .then(() => this.doSomething())\n  .catch(() => this.handleError())\n```\n","h2":"Helpful tips"},{"title":"Inheriting data-attributes from parent elements","elms":"\nYou can use the `data-reflex-dataset=\"combined\"` directive to scoop all data attributes up the DOM hierarchy and pass them as part of the Reflex payload.\n\n```erb\n<!-- new.html.erb -->\n<div data-post-id=\"<%= @post.id %>\">\n  <div data-category-id=\"<%= @category.id %>\">\n    <button data-reflex=\"click->Comment#create\" data-reflex-dataset=\"combined\">Create</button>\n  </div>\n</div>\n```\n\n```ruby\n# comment_reflex.rb\nclass CommentReflex < ApplicationReflex\n  def create\n    puts element.dataset[\"post-id\"]\n    puts element.dataset[\"category-id\"]\n  end\nend\n```\n","h2":"Helpful tips"},{"title":"Reflex root","elms":"\nInstead of updating your entire page, you can specify exactly which parts of the DOM will be updated using the `data-reflex-root` attribute. [Full docs](http://docs.stimulusreflex.com/morph-modes#scoping-page-morphs)\n\n```text\n<!-- index.html.erb -->\n<div data-reflex-root=\"[forward],[backward]\">\n  <input type=\"text\" value=\"<%= @words %>\" data-reflex=\"keyup->Example#words\">\n  <div forward><%= @words %></div>\n  <div backward><%= @words&.reverse %></div>\n</div>\n```\n\n```ruby\n# example_reflex.rb\n  def words\n    @words = element[:value]\n  end\n```\n","h2":"Helpful tips"},{"title":"Permanent elements","elms":"\nAdd data-reflex-permanent to any element in your DOM, and it will be left unchanged by full-page Reflex updates and morph calls that re-render partials.\n\n```erb\n<!-- index.html.erb -->\n<div data-reflex-permanent>\n  <iframe src=\"https://ghbtns.com/github-btn.html?user=hopsoft&repo=stimulus_reflex&type=star&count=true\" frameborder=\"0\" scrolling=\"0\" class=\"ghbtn\"></iframe>\n  <iframe src=\"https://ghbtns.com/github-btn.html?user=hopsoft&repo=stimulus_reflex&type=fork&count=true\" frameborder=\"0\" scrolling=\"0\" class=\"ghbtn\"></iframe>\n</div>\n```\n","h2":"Helpful tips"},{"title":"Aborting a reflex","elms":"\ncall `raise :abort` within a reflex method to cancel it.\n\n```ruby\n# comment_reflex.rb\nclass CommentReflex < ApplicationReflex\n  def create\n    raise :abort\n  end\nend\n```","h2":"Helpful tips"}]}