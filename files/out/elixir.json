{"head":{"title":"Elixir","category":"Elixir","layout":"2017/sheet","tags":["New"],"updated":"2018-07-04T00:00:00.000Z","weight":-10},"body":[{"title":null,"elms":"{: .-three-column}\n","h2":"Getting started"},{"title":"Hello world","elms":"{: .-prime}\n\n```elixir\n# hello.exs\ndefmodule Greeter do\n  def greet(name) do\n    message = \"Hello, \" <> name <> \"!\"\n    IO.puts message\n  end\nend\n\nGreeter.greet(\"world\")\n```\n\n```bash\nelixir hello.exs\n# Hello, world!\n```\n{: .-setup}\n","h2":"Getting started"},{"title":"Variables","elms":"\n```elixir\nage = 23\n```\n","h2":"Getting started"},{"title":"Maps","elms":"\n```elixir\nuser = %{\n  name: \"John\",\n  city: \"Melbourne\"\n}\n```\n\n```elixir\nIO.puts \"Hello, \" <> user.name\n```\n{: .-setup}\n","h2":"Getting started"},{"title":"Lists","elms":"\n```elixir\nusers = [ \"Tom\", \"Dick\", \"Harry\" ]\n```\n{: data-line=\"1\"}\n\n```elixir\nEnum.map(users, fn user ->\n  IO.puts \"Hello \" <> user\nend)\n```\n","h2":"Getting started"},{"title":"Piping","elms":"\n```elixir\nsource\n|> transform(:hello)\n|> print()\n```\n{: data-line=\"2,3\"}\n\n```elixir\n# Same as:\nprint(transform(source, :hello))\n```\n\nThese two are equivalent.\n","h2":"Getting started"},{"title":"Pattern matching","elms":"\n```elixir\nuser = %{name: \"Tom\", age: 23}\n%{name: username} = user\n```\n{: data-line=\"2\"}\n\nThis sets `username` to `\"Tom\"`.\n","h2":"Getting started"},{"title":"Pattern matching in functions","elms":"\n```elixir\ndef greet(%{name: username}) do\n  IO.puts \"Hello, \" <> username\nend\n\nuser = %{name: \"Tom\", age: 23}\n```\n{: data-line=\"1\"}\n\nPattern matching works in function parameters too.\n\nControl flow\n------------\n{: .-three-column}\n","h2":"Getting started"},{"title":"If","elms":"\n```elixir\nif false do\n  \"This will never be seen\"\nelse\n  \"This will\"\nend\n```","h2":"Getting started"},{"title":"Case","elms":"\n```elixir\ncase {1, 2, 3} do\n  {4, 5, 6} ->\n    \"This clause won't match\"\n  {1, x, 3} ->\n    \"This will match and bind x to 2\"\n  _ ->\n   \"This will match any value\"\nend\n```\n","h2":"Getting started"},{"title":"Cond","elms":"\n```elixir\ncond do\n  1 + 1 == 3 ->\n    \"I will never be seen\"\n  2 * 5 == 12 ->\n    \"Me neither\"\n  true ->\n    \"But I will (this is essentially an else)\"\nend\n```\n","h2":"Getting started"},{"title":"Errors","elms":"\n```elixir\ntry do\n  throw(:hello)\ncatch\n  message -> \"Got #{message}.\"\nafter\n  IO.puts(\"I'm the after clause.\")\nend\n```\n","h2":"Getting started"},{"title":"Primitives","elms":"\n| Sample                  | Type            |\n| ---                     | ---             |\n| `nil`                   | Nil/null        |\n| `true` _/_ `false`      | Boolean         |\n| ---                     | ---             |\n| `?a`                    | Integer (ASCII) |\n| `23`                    | Integer         |\n| `3.14`                  | Float           |\n| ---                     | ---             |\n| `'hello'`               | Charlist        |\n| `<<2, 3>>`              | Binary          |\n| `\"hello\"`               | Binary string   |\n| `:hello`                | Atom            |\n| ---                     | ---             |\n| `[a, b]`                | List            |\n| `{a, b}`                | Tuple           |\n| ---                     | ---             |\n| `%{a: \"hello\"}`         | Map             |\n| `%MyStruct{a: \"hello\"}` | Struct          |\n| `fn -> ... end`         | Function        |\n","h2":"Types"},{"title":"Type checks","elms":"\n```elixir\nis_atom/1\nis_bitstring/1\nis_boolean/1\nis_function/1\nis_function/2\nis_integer/1\nis_float/1\n```\n\n```elixir\nis_binary/1\nis_list/1\nis_map/1\nis_tuple/1\n```\n\n```elixir\nis_nil/1\nis_number/1\nis_pid/1\nis_port/1\nis_reference/1\n```\n","h2":"Types"},{"title":"Operators","elms":"\n```elixir\nleft != right   # equal\nleft !== right  # match\nleft ++ right   # concat lists\nleft <> right   # concat string/binary\nleft =~ right   # regexp\n```\n\nModules\n-------\n","h2":"Types"},{"title":"Importing","elms":"\n```elixir\nrequire Redux   # compiles a module\nimport Redux    # compiles, and you can use without the `Redux.` prefix\n\nuse Redux       # compiles, and runs Redux.__using__/1\nuse Redux, async: true\n\nimport Redux, only: [duplicate: 2]\nimport Redux, only: :functions\nimport Redux, only: :macros\n\nimport Foo.{Bar, Baz}\n```\n","h2":"Types"},{"title":"Aliases","elms":"\n```elixir\nalias Foo.Bar, as: Bar\nalias Foo.Bar   # same as above\n\nalias Foo.{Bar, Baz}\n```\n","h2":"Types"},{"title":"Functions","elms":"\n```elixir\nimport String\n```\n{: .-setup}\n\n```elixir\nstr = \"hello\"\nstr |> length()        # → 5\nstr |> codepoints()    # → [\"h\", \"e\", \"l\", \"l\", \"o\"]\nstr |> slice(2..-1)    # → \"llo\"\nstr |> split(\" \")      # → [\"hello\"]\nstr |> capitalize()    # → \"Hello\"\nstr |> match(regex)\n```\n","h2":"String"},{"title":"Inspecting objects","elms":"\n```elixir\ninspect(object, opts \\\\ [])\n```\n```elixir\nvalue |> IO.inspect()\n```\n```elixir\nvalue |> IO.inspect(label: \"value\")\n```\n","h2":"String"},{"title":"Operations","elms":"\n```elixir\nabs(n)\nround(n)\nrem(a, b)   # remainder (modulo)\ndiv(a, b)   # integer division\n```\n","h2":"Numbers"},{"title":"Float","elms":"\n```elixir\nimport Float\n```\n{: .-setup}\n\n```elixir\nn = 10.3\n```\n{: .-setup}\n\n```elixir\nn |> ceil()            # → 11.0\nn |> ceil(2)           # → 11.30\nn |> to_string()       # → \"1.030000+e01\"\nn |> to_string([decimals: 2, compact: true])\n```\n\n```elixir\nFloat.parse(\"34\")  # → { 34.0, \"\" }\n```\n","h2":"Numbers"},{"title":"Integer","elms":"\n```elixir\nimport Integer\n```\n{: .-setup}\n\n```elixir\nn = 12\n```\n{: .-setup}\n\n```elixir\nn |> digits()         # → [1, 2]\nn |> to_charlist()    # → '12'\nn |> to_string()      # → \"12\"\nn |> is_even()\nn |> is_odd()\n```\n\n```elixir\n# Different base:\nn |> digits(2)        # → [1, 1, 0, 0]\nn |> to_charlist(2)   # → '1100'\nn |> to_string(2)     # → \"1100\"\n```\n\n```elixir\nparse(\"12\")           # → {12, \"\"}\nundigits([1, 2])      # → 12\n```\n","h2":"Numbers"},{"title":"Type casting","elms":"\n```elixir\nFloat.parse(\"34.1\")    # → {34.1, \"\"}\nInteger.parse(\"34\")    # → {34, \"\"}\n```\n\n```elixir\nFloat.to_string(34.1)  # → \"3.4100e+01\"\nFloat.to_string(34.1, [decimals: 2, compact: true])  # → \"34.1\"\n```\n","h2":"Numbers"},{"title":"Defining","elms":"\n```elixir\nm = %{name: \"hi\"}       # atom keys (:name)\nm = %{\"name\" => \"hi\"}   # string keys (\"name\")\n```\n","h2":"Map"},{"title":"Updating","elms":"\n```elixir\nimport Map\n```\n{: .-setup}\n\n```elixir\nm = %{m | name: \"yo\"}  # key must exist\n```\n\n```elixir\nm |> put(:id, 2)      # → %{id: 2, name: \"hi\"}\nm |> put_new(:id, 2)  # only if `id` doesn't exist (`||=`)\n```\n\n```elixir\nm |> put(:b, \"Banana\")\nm |> merge(%{b: \"Banana\"})\nm |> update(:a, &(&1 + 1))\nm |> update(:a, fun a -> a + 1 end)\n```\n\n```elixir\nm |> get_and_update(:a, &(&1 || \"default\"))\n# → {old, new}\n```\n","h2":"Map"},{"title":"Deleting","elms":"\n```elixir\nm |> delete(:name)  # → %{}\nm |> pop(:name)     # → {\"John\", %{}}\n```\n","h2":"Map"},{"title":"Reading","elms":"\n```elixir\nm |> get(:id)       # → 1\nm |> keys()         # → [:id, :name]\nm |> values()       # → [1, \"hi\"]\n```\n\n```elixir\nm |> to_list()      # → [id: 1, name: \"hi\"]\n                    # → [{:id, 1}, {:name, \"hi\"}]\n```\n","h2":"Map"},{"title":"Deep","elms":"\n```elixir\nput_in(map, [:b, :c], \"Banana\")\nput_in(map[:b][:c], \"Banana\")    # via macros\n```\n\n```elixir\nget_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n```\n","h2":"Map"},{"title":"Constructing from lists","elms":"\n```elixir\nMap.new([{:b, 1}, {:a, 2}])\nMap.new([a: 1, b: 2])\nMap.new([:a, :b], fn x -> {x, x} end)  # → %{a: :a, b: :b}\n```\n","h2":"Map"},{"title":"Working with structs","elms":"\n#### Struct to map\n\n```elixir\nMap.from_struct(%AnyStruct{a: \"b\"})  # → %{a: \"b\"}\n```\n\n#### Map to struct\n\n```elixir\nstruct(AnyStruct, %{a: \"b\"})  # → %AnyStruct{a: \"b\"}\n```\n","h2":"Map"},{"title":null,"elms":"\n```elixir\nimport List\n```\n{: .-setup}\n\n```elixir\nl = [ 1, 2, 3, 4 ]\n```\n{: .-setup}\n\n```elixir\nl = l ++ [5]         # push (append)\nl = [ 0 | list ]     # unshift (prepend)\n```\n\n```elixir\nl |> first()\nl |> last()\n```\n\n```elixir\nl |> flatten()\nl |> flatten(tail)\n```\n\nAlso see [Enum](#enum).\n\n","h2":"List"},{"title":"Usage","elms":"\n```elixir\nimport Enum\n```\n{: .-setup}\n\n```elixir\nlist = [:a, :b, :c]\n```\n{: .-setup}\n\n```elixir\nlist |> at(0)         # → :a\nlist |> count()       # → 3\nlist |> empty?()      # → false\nlist |> any?()        # → true\n```\n\n```elixir\nlist |> concat([:d])  # → [:a, :b, :c, :d]\n```\n\nAlso, consider streams instead.\n","h2":"Enum"},{"title":"Map/reduce","elms":"\n```elixir\nlist |> reduce(fn)\nlist |> reduce(acc, fn)\nlist |> map(fn)\nlist |> reject(fn)\nlist |> any?(fn)\nlist |> empty?(fn)\n```\n\n```elixir\n[1, 2, 3, 4]\n|> Enum.reduce(0, fn(x, acc) -> x + acc end)\n```\n","h2":"Enum"},{"title":"Tuples","elms":"\n```elixir\nimport Tuple\n```\n{: .-setup}\n\n```elixir\nt = { :a, :b }\n```\n\n```elixir\nt |> elem(1)    # like tuple[1]\nt |> put_elem(index, value)\nt |> tuple_size()\n```\n","h2":"Tuple"},{"title":"Keyword lists","elms":"\n```elixir\nlist = [{ :name, \"John\" }, { :age, 15 }]\nlist[:name]\n```\n\n```elixir\n# For string-keyed keyword lists\nlist = [{\"size\", 2}, {\"type\", \"shoe\"}]\nList.keyfind(list, \"size\", 0)  # → {\"size\", 2}\n```\n","h2":"Tuple"},{"title":"Lambdas","elms":"\n```elixir\nsquare = fn n -> n*n end\nsquare.(20)\n```\n","h2":"Functions"},{"title":"& syntax","elms":"\n```elixir\nsquare = &(&1 * &1)\nsquare.(20)\n\nsquare = &Math.square/1\n```\n","h2":"Functions"},{"title":"Running","elms":"\n```elixir\nfun.(args)\napply(fun, args)\napply(module, fun, args)\n```\n","h2":"Functions"},{"title":"Function heads","elms":"\n```elixir\ndef join(a, b \\\\ nil)\ndef join(a, b) when is_nil(b) do: a\ndef join(a, b) do: a <> b\n```\n","h2":"Functions"},{"title":"Structs","elms":"\n```elixir\ndefmodule User do\n  defstruct name: \"\", age: nil\nend\n\n%User{name: \"John\", age: 20}\n\n%User{}.struct  # → User\n```\n\nSee: [Structs](http://elixir-lang.org/getting-started/structs.html)\n","h2":"Structs"},{"title":"Defining protocols","elms":"\n```elixir\ndefprotocol Blank do\n  @doc \"Returns true if data is considered blank/empty\"\n  def blank?(data)\nend\n```\n\n```elixir\ndefimpl Blank, for: List do\n  def blank?([]), do: true\n  def blank?(_), do: false\nend\n\nBlank.blank?([])  # → true\n```\n","h2":"Protocols"},{"title":"Any","elms":"\n```elixir\ndefimpl Blank, for: Any do ... end\n\ndefmodule User do\n  @derive Blank     # Falls back to Any\n  defstruct name: \"\"\nend\n```\n","h2":"Protocols"},{"title":"Examples","elms":"\n- `Enumerable` and `Enum.map()`\n- `Inspect` and `inspect()`\n","h2":"Protocols"},{"title":"For","elms":"\n```elixir\nfor n <- [1, 2, 3, 4], do: n * n\nfor n <- 1..4, do: n * n\n```\n\n```elixir\nfor {key, val} <- %{a: 10, b: 20}, do: val\n# → [10, 20]\n```\n\n```elixir\nfor {key, val} <- %{a: 10, b: 20}, into: %{}, do: {key, val*val}\n```\n","h2":"Comprehensions"},{"title":"Conditions","elms":"\n```elixir\nfor n <- 1..10, rem(n, 2) == 0, do: n\n# → [2, 4, 6, 8, 10]\n```\n","h2":"Comprehensions"},{"title":"Complex","elms":"\n```elixir\nfor dir <- dirs,\n    file <- File.ls!(dir),          # nested comprehension\n    path = Path.join(dir, file),    # invoked\n    File.regular?(path) do          # condition\n  IO.puts(file)\nend\n```\n","h2":"Comprehensions"},{"title":"Metaprogramming","elms":"\n```elixir\n__MODULE__\n__MODULE__.__info__\n\n@after_compile __MODULE__\ndef __before_compile__(env)\ndef __after_compile__(env, _bytecode)\ndef __using__(opts)    # invoked on `use`\n\n@on_definition {__MODULE__, :on_def}\ndef on_def(_env, kind, name, args, guards, body)\n\n@on_load :load_check\ndef load_check\n```\n","h2":"Misc"},{"title":"Regexp","elms":"\n```elixir\nexp = ~r/hello/\nexp = ~r/hello/i\n\"hello world\" =~ exp\n```\n","h2":"Misc"},{"title":"Sigils","elms":"\n```elixir\n~r/regexp/\n~w(list of strings)\n~s|strings with #{interpolation} and \\x20 escape codes|\n~S|no interpolation and no escapes|\n~c(charlist)\n```\n\nAllowed chars: `/` `|` `\"` `'` `(` `[` `{` `<` `\"\"\"`.\nSee: [Sigils](http://elixir-lang.org/getting-started/sigils.html)\n","h2":"Misc"},{"title":"Type specs","elms":"\n```elixir\n@spec round(number) :: integer\n\n@type number_with_remark :: {number, String.t}\n@spec add(number, number) :: number_with_remark\n```\n\nUseful for [dialyzer](http://www.erlang.org/doc/man/dialyzer.html).\nSee: [Typespecs](http://elixir-lang.org/getting-started/typespecs-and-behaviours.html)\n","h2":"Misc"},{"title":"Behaviours","elms":"\n```elixir\ndefmodule Parser do\n  @callback parse(String.t) :: any\n  @callback extensions() :: [String.t]\nend\n```\n\n```elixir\ndefmodule JSONParser do\n  @behaviour Parser\n\n  def parse(str), do: # ... parse JSON\n  def extensions, do: [\"json\"]\nend\n```\n\nSee: [Module](http://elixir-lang.org/docs/stable/elixir/Module.html)\n","h2":"Misc"},{"title":null,"elms":"{: .-one-column}\n\n- [Learn Elixir in Y minutes](https://learnxinyminutes.com/docs/elixir/)","h2":"References"}]}